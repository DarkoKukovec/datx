import {
  getModelCollection,
  getModelId,
  getModelMetaKey,
  getModelType,
  getRefId,
  IIdentifier,
  modelToJSON,
  PureModel,
  ReferenceType,
  setModelMetaKey,
} from 'datx';
import {IDictionary, IRawModel, mapItems, META_FIELD} from 'datx-utils';

import {
  MODEL_LINKS_FIELD,
  MODEL_META_FIELD,
  MODEL_PERSISTED_FIELD,
  MODEL_REF_LINKS_FIELD,
  MODEL_REF_META_FIELD,
} from '../consts';
import {IJsonapiCollection} from '../interfaces/IJsonapiCollection';
import {IJsonapiModel} from '../interfaces/IJsonapiModel';
import {IRequestOptions} from '../interfaces/IRequestOptions';
import {IDefinition, ILink, IRecord, IRelationship} from '../interfaces/JsonApi';
import {config, create, fetchLink, handleResponse, remove, update} from '../NetworkUtils';
import {Response} from '../Response';
import {getValue} from './utils';

export function flattenModel(): null;
export function flattenModel(data?: IRecord): IRawModel;
export function flattenModel(data?: IRecord): IRawModel|null {
  if (!data) {
    return null;
  }

  const rawData = {
    [META_FIELD]: {
      fields: Object.keys(data.attributes),
      id: data.id,
      [MODEL_LINKS_FIELD]: data.links,
      [MODEL_META_FIELD]: data.meta,
      [MODEL_PERSISTED_FIELD]: Boolean(data.id),
      refs: {},
      type: data.type,
    },
  };

  if (data.relationships) {
    const refLinks = {};
    const refMeta = {};
    const refs = {};
    Object.keys(data.relationships).forEach((key) => {
      const ref = (data.relationships as IDictionary<IRelationship>)[key] as IRelationship;
      if ('data' in ref && ref.data) {
        rawData[key] = mapItems(ref.data, (item: IDefinition) => item.id);
        refs[key] = {
          model: ref.data instanceof Array ? ref.data[0].type : ref.data.type,
          type: ref.data instanceof Array ? ReferenceType.TO_MANY : ReferenceType.TO_ONE,
        };
      }
      if ('links' in ref) {
        refLinks[key] = ref.links;
      }
      if ('meta' in ref) {
        refMeta[key] = ref.meta;
      }
    });

    rawData[META_FIELD].refs = refs;
    rawData[META_FIELD][MODEL_REF_LINKS_FIELD] = refLinks;
    rawData[META_FIELD][MODEL_REF_META_FIELD] = refMeta;
  }

  return Object.assign(rawData, data.attributes);
}

export function getModelMeta(model: PureModel): IDictionary<any> {
  return getModelMetaKey(model, MODEL_META_FIELD);
}

export function getModelLinks(model: PureModel): IDictionary<ILink> {
  return getModelMetaKey(model, MODEL_LINKS_FIELD);
}

export async function fetchModelLink<T extends IJsonapiModel = IJsonapiModel>(
  model: PureModel,
  key: string,
  requestHeaders?: IDictionary<string>,
  options?: IRequestOptions,
): Promise<Response<T>> {
  const collection = getModelCollection(model);
  if (!collection) {
    throw new Error('The model needs to be in a collection');
  }
  const links = getModelLinks(model);
  if (!(key in links)) {
    throw new Error(`Link ${key} doesn't exist on the model`);
  }
  const link = links[key];
  return fetchLink<T>(link, collection as IJsonapiCollection, requestHeaders, options);
}

export async function fetchModelRefLink<T extends IJsonapiModel = IJsonapiModel>(
  model: PureModel,
  ref: string,
  key: string,
  requestHeaders?: IDictionary<string>,
  options?: IRequestOptions,
): Promise<Response<T>> {
  const collection = getModelCollection(model);
  if (!collection) {
    throw new Error('The model needs to be in a collection');
  }
  const links = getModelRefLinks(model);
  if (!(ref in links)) {
    throw new Error(`The reference ${ref} doesn't have any links`);
  }
  const refLinks = links[ref];
  if (!(key in refLinks)) {
    throw new Error(`Link ${key} doesn't exist on the model`);
  }
  const link = refLinks[key];
  return fetchLink<T>(link, collection as IJsonapiCollection, requestHeaders, options);
}

export function getModelRefLinks(model: PureModel): IDictionary<IDictionary<ILink>> {
  return getModelMetaKey(model, MODEL_REF_LINKS_FIELD);
}

export function getModelRefMeta(model: PureModel): IDictionary<any> {
  return getModelMetaKey(model, MODEL_REF_META_FIELD);
}

function isModelPersisted(model: PureModel): boolean {
  return getModelMetaKey(model, MODEL_PERSISTED_FIELD);
}

function setModelPersisted(model: PureModel, status: boolean) {
  setModelMetaKey(model, MODEL_PERSISTED_FIELD, status);
}

export function modelToJsonApi(model: IJsonapiModel): IRecord {
  const staticModel = model.constructor as typeof PureModel;
  const attributes: IDictionary<any> = modelToJSON(model);

  const useAutogenerated: boolean = staticModel['useAutogeneratedIds'];
  const isPersisted = isModelPersisted(model);

  const data: IRecord = {
    attributes,
    id: (isPersisted || useAutogenerated) ? getModelId(model) : undefined,
    type: getModelType(model) as string,
  };

  const refs = getModelMetaKey(model, 'refs');

  Object.keys(refs).forEach((key) => {
    data.relationships = data.relationships || {};
    const refIds = getRefId(model, key);
    const rel = mapItems(refIds, (id: IIdentifier) => {
      const type = model[key] ? getModelType(model[key]) : refs[key].model;
      return {id, type};
    });

    data.relationships[key] = {data: rel} as IRelationship;
    delete data.attributes[key];
  });

  delete data.attributes[META_FIELD];

  return data;
}

function getModelEndpointUrl(model: PureModel): string {
  const staticModel = model.constructor as PureModel;
  const links: IDictionary<ILink> = getModelLinks(model);
  if (links && links.self) {
    const self: ILink = links.self;
    return typeof self === 'string' ? self : self.href;
  }

  const url = getValue<string>(staticModel['endpoint']) || getModelType(model);

  return isModelPersisted(model)
    ? `${config.baseUrl}${url}/${getModelId(model)}`
    : `${config.baseUrl}${url}`;
}

export function saveModel(model: IJsonapiModel, options?: IRequestOptions): Promise<IJsonapiModel> {
  const collection = getModelCollection(model) as IJsonapiCollection;

  const data: IRecord = modelToJsonApi(model);
  const requestMethod = isModelPersisted(model) ? update : create;
  const url = getModelEndpointUrl(model);
  return requestMethod(collection, url, {data}, options && options.headers)
    .then(handleResponse(model));
}

export function removeModel<T extends IJsonapiModel>(model: T, options?: IRequestOptions): Promise<void> {
  const collection = getModelCollection(model) as IJsonapiCollection;

  const isPersisted = isModelPersisted(model);
  const url = getModelEndpointUrl(model);

  if (isPersisted) {
    return remove(collection, url, options && options.headers)
      .then((response: Response<T>) => {
        if (response.error) {
          throw response.error;
        }

        setModelPersisted(model, false);

        collection.remove(model);
      });
  }

  return Promise.resolve();
}
