import {
  getModelCollection,
  getModelId,
  getModelMetaKey,
  getModelType,
  modelToJSON,
  PureModel,
  setModelMetaKey,
} from 'datx';
import {IDictionary, IRawModel, mapItems, META_FIELD} from 'datx-utils';

import {MODEL_LINKS_FIELD, MODEL_META_FIELD, MODEL_PERSISTED_FIELD, MODEL_REF_LINKS_FIELD} from '../consts';
import {IJsonapiCollection} from '../interfaces/IJsonapiCollection';
import {IJsonapiModel} from '../interfaces/IJsonapiModel';
import {IRequestOptions} from '../interfaces/IRequestOptions';
import {IDefinition, ILink, IRecord, IRelationship} from '../interfaces/JsonApi';
import {config, create, handleResponse, remove, update} from '../NetworkUtils';
import {Response} from '../Response';
import {getValue} from './utils';

export function flattenModel(): null;
export function flattenModel(data?: IRecord): IRawModel;
export function flattenModel(data?: IRecord): IRawModel|null {
  if (!data) {
    return null;
  }

  const rawData = {
    [META_FIELD]: {
      fields: Object.keys(data.attributes),
      id: data.id,
      [MODEL_LINKS_FIELD]: data.links,
      [MODEL_META_FIELD]: data.meta,
      [MODEL_PERSISTED_FIELD]: Boolean(data.id),
      type: data.type,
    },
  };

  if (data.relationships) {
    const refLinks = {};
    Object.keys(data.relationships).forEach((key) => {
      const ref = (data.relationships as IDictionary<IRelationship>)[key] as IRelationship;
      if ('data' in ref) {
        rawData[key] = mapItems(ref.data, (item: IDefinition) => item.id);
      }
      if ('links' in ref) {
        refLinks[key] = ref.links;
      }
    });

    rawData[META_FIELD][MODEL_REF_LINKS_FIELD] = refLinks;
  }

  return Object.assign(rawData, data.attributes);
}

export function getModelMeta(model: PureModel): IDictionary<any> {
  return getModelMetaKey(model, MODEL_META_FIELD);
}

export function getModelLinks(model: PureModel): IDictionary<ILink> {
  return getModelMetaKey(model, MODEL_LINKS_FIELD);
}

export function getModelRefLinks(model: PureModel): IDictionary<ILink> {
  return getModelMetaKey(model, MODEL_REF_LINKS_FIELD);
}

function isModelPersisted(model: PureModel): boolean {
  return getModelMetaKey(model, MODEL_PERSISTED_FIELD);
}

function setModelPersisted(model: PureModel, status: boolean) {
  setModelMetaKey(model, MODEL_PERSISTED_FIELD, status);
}

export function modelToJsonApi(model: IJsonapiModel): IRecord {
  const staticModel = model.constructor as typeof PureModel;
  const attributes: IDictionary<any> = modelToJSON(model);

  const useAutogenerated: boolean = staticModel['useAutogeneratedIds'];
  const isPersisted = isModelPersisted(model);

  const data: IRecord = {
    attributes,
    id: (isPersisted || useAutogenerated) ? getModelId(model) : undefined,
    type: getModelType(model) as string,
  };

  const refs = getModelMetaKey(model, 'refs');

  Object.keys(refs).forEach((key) => {
    data.relationships = data.relationships || {};
    const rel = mapItems(model[key], (item: PureModel) => {
      const id = getModelId(item);
      const type = getModelType(item);
      return {id, type};
    });

    data.relationships[key] = {data: rel} as IRelationship;
    delete data.attributes[key];
  });

  return data;
}

function getModelEndpointUrl(model: PureModel): string {
  const staticModel = model.constructor as PureModel;
  const links: IDictionary<ILink> = getModelLinks(model);
  if (links && links.self) {
    const self: ILink = links.self;
    return typeof self === 'string' ? self : self.href;
  }

  const url = getValue<string>(staticModel['endpoint']) || getModelType(model);

  return isModelPersisted(model)
    ? `${config.baseUrl}${url}/${getModelId(model)}`
    : `${config.baseUrl}${url}`;
}

export function saveModel(model: IJsonapiModel, options?: IRequestOptions): Promise<IJsonapiModel> {
  const collection = getModelCollection(model) as IJsonapiCollection;

  const data: IRecord = modelToJsonApi(model);
  const requestMethod = isModelPersisted(model) ? update : create;
  const url = getModelEndpointUrl(model);
  return requestMethod(collection, url, {data}, options && options.headers)
    .then(handleResponse(model));
}

export function removeModel(model: PureModel, options?: IRequestOptions): Promise<void> {
  const collection = getModelCollection(model) as IJsonapiCollection;

  const isPersisted = isModelPersisted(model);
  const url = getModelEndpointUrl(model);

  if (isPersisted) {
    return remove(collection, url, options && options.headers)
      .then((response: Response) => {
        if (response.error) {
          throw response.error;
        }

        setModelPersisted(model, false);

        collection.remove(model);
      });
  }

  return Promise.resolve();
}
